# 8/6题目

## 螺旋矩阵

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806104725930.png" alt="image-20210806104725930" style="zoom:50%;" />

方法：模拟

> 生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：
> 定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n * n；
> 当 num <= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：
> 执行 num += 1：得到下一个需要填入的数字；
> 更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。
> 使用num <= tar而不是l < r || t < b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。

```java
public int[][]generateMatrix(int n){
        int[][]res=new int[n][n];
        int up=0,down=n-1,left=0,right=n-1,index=1;
        while(index<=n*n){
        for(int i=left;i<=right;i++){
        res[up][i]=index++;
        }
        up++;
        for(int i=up;i<=down;i++){
        res[i][right]=index++;
        }
        right--;
        for(int i=right;i>=left;i--){
        res[down][i]=index++;
        }
        down--;
        for(int i=down;i>=up;i--){
        res[i][left]=index++;
        }
        left++;
        }
        return res;
        }
```

## 排列排序

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806105551154.png" alt="image-20210806105551154" style="zoom:50%;" />'
.'

方法：数学方法

## 旋转链表

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806110603824.png" alt="image-20210806110603824" style="zoom: 50%;" />

方法：闭合为环

~~~java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (k == 0 || head == null || head.next == null) {
            return head;
        }
        int n = 1;
        ListNode iter = head;
        while (iter.next != null) {
            iter = iter.next;
            n++;
        }
        int add = n - k % n;
        if (add == n) {
            return head;
        }
        iter.next = head;
        while (add-- > 0) {
            iter = iter.next;
        }
        ListNode ret = iter.next;
        iter.next = null;
        return ret;
    }
}

~~~

## 不同路径

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806111018183.png" alt="image-20210806111018183" style="zoom:50%;" />

方法：动态规划

f(m,n)=f(m-1,n)+f(m,n-1)

之后就类似斐波那契数列的处理。

~~~ java
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        for (int i = 0; i < m; ++i) {
            f[i][0] = 1;
        }
        for (int j = 0; j < n; ++j) {
            f[0][j] = 1;
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
}
~~~

## 不同路径2号

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806113435057.png" alt="image-20210806113435057" style="zoom:50%;" />

就是在一号的基础上吧f（k,j）位置为0

~~~ java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n = obstacleGrid.length, m = obstacleGrid[0].length;
        int[] f = new int[m];

        f[0] = obstacleGrid[0][0] == 0 ? 1 : 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    f[j] = 0;
                    continue;
                }
                if (j - 1 >= 0 && obstacleGrid[i][j - 1] == 0) {
                    f[j] += f[j - 1];
                }
            }
        }
        
        return f[m - 1];
    }
}

~~~

## 最小路径和

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806130257943.png" alt="image-20210806130257943" style="zoom:50%;" />

方法：动态规划

~~~java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rows = grid.length, columns = grid[0].length;
        int[][] dp = new int[rows][columns];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < columns; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < columns; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[rows - 1][columns - 1];
    }
}


~~~

## 矩阵置零

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806144640211.png" alt="image-20210806144640211" style="zoom:50%;" />

方法：各用一个数组表现行与列的布尔值

```
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = col[j] = true;
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] || col[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

# 8/9题目

## 最小覆盖子串

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210809094100760.png" alt="image-20210809094100760" style="zoom:50%;" />

方法：滑动窗口

```  java
class Solution {
    Map<Character, Integer> ori = new HashMap<Character, Integer>();
    Map<Character, Integer> cnt = new HashMap<Character, Integer>();

    public String minWindow(String s, String t) {
        int tLen = t.length();
        for (int i = 0; i < tLen; i++) {
            char c = t.charAt(i);
            ori.put(c, ori.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;
        int sLen = s.length();
        while (r < sLen) {
            ++r;
            if (r < sLen && ori.containsKey(s.charAt(r))) {
                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);
            }
            while (check() && l <= r) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                if (ori.containsKey(s.charAt(l))) {
                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);
                }
                ++l;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    public boolean check() {
        Iterator iter = ori.entrySet().iterator(); 
        while (iter.hasNext()) { 
            Map.Entry entry = (Map.Entry) iter.next(); 
            Character key = (Character) entry.getKey(); 
            Integer val = (Integer) entry.getValue(); 
            if (cnt.getOrDefault(key, 0) < val) {
                return false;
            }
        } 
        return true;
    }
}
```

## 组合

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210809094325149.png" alt="image-20210809094325149" style="zoom:50%;" />

方法：

``` 
class Solution {
    List<Integer> temp = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> combine(int n, int k) {
        dfs(1, n, k);
        return ans;
    }

    public void dfs(int cur, int n, int k) {
        // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp
        if (temp.size() + (n - cur + 1) < k) {
            return;
        }
        // 记录合法的答案
        if (temp.size() == k) {
            ans.add(new ArrayList<Integer>(temp));
            return;
        }
        // 考虑选择当前位置
        temp.add(cur);
        dfs(cur + 1, n, k);
        temp.remove(temp.size() - 1);
        // 考虑不选择当前位置
        dfs(cur + 1, n, k);
    }
}

```

## 子集问题

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210809095606082.png" alt="image-20210809095606082" style="zoom:50%;" />

方法：还是回溯法和全排列有些像

~~~ 
class Solution {
   public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        dfs(nums, 0, nums.length, path, res);
        return res;
    }

    private void dfs(int[] nums, int begin, int n, List<Integer> path, List<List<Integer>> res) {
        res.add(new ArrayList<>(path));
        for (int i=begin; i<n; i++) {
            path.add(nums[i]);
            dfs(nums, i+1, n, path, res);
            path.remove(path.size()-1);
        }
    }
}
~~~

### 回溯法有个模板

即：

``` 
List<List<Integer>> result = new ArrayList<>();
void backtrack(路径,选择列表){
    if(符合结束条件){
        result.push_back(路径);
        return;
    }
    for(选择 : 选择列表){
        做选择;路径增加选择;选择列表删除选择;
        backtrack(路径,选择列表);
        撤销选择;路径取消选择;选择列表添加选择;
    }
}
```

# 8/11

## 子集Ⅱ

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210811091627188.png" alt="image-20210811091627188" style="zoom:50%;" />

相比与普通求子集，就是去除了重复部分 在当前位置的数若是与上一个数相同，则不加入跳过。

~~~ 
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        dfs(false, 0, nums);
        return ans;
    }

    public void dfs(boolean choosePre, int cur, int[] nums) {
        if (cur == nums.length) {
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        dfs(false, cur + 1, nums);
        if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {
            return;
        }
        t.add(nums[cur]);
        dfs(true, cur + 1, nums);
        t.remove(t.size() - 1);
    }
}
~~~

# 8/12

## 复原ip地址

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812082233473.png" alt="image-20210812082233473" style="zoom:50%;" />

方法：回溯法，暴力解法

``` 
1.暴力解法：
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> list = new ArrayList();
        for(int a=1; a<4; a++){
            for(int b=1; b<4; b++){
                for(int c=1; c<4; c++){
                    for(int d=1; d<4; d++){
                        if(a+b+c+d==s.length()){
                            String s1 = s.substring(0, a);
                            String s2 = s.substring(a, a+b);
                            String s3 = s.substring(a+b, a+b+c);
                            String s4 = s.substring(a+b+c, a+b+c+d);

                            if(check(s1)&&check(s2)&&check(s3)&&check(s4)){
                                String ip = s1+"."+s2+"."+s3+"."+s4;
                                list.add(ip);
                            }
                        }
                    }
                }
            }
        }
        return list;
    }

    public boolean check(String s){
        if(Integer.valueOf(s)<=255){
            if(s.charAt(0)!='0' || s.charAt(0)=='0'&&s.length()==1) 
                return true;
        }
        return false;
    }
}
```

~~~ java
2.回溯法
class Solution {
    static final int SEG_COUNT = 4;
    List<String> ans = new ArrayList<String>();
    int[] segments = new int[SEG_COUNT];

    public List<String> restoreIpAddresses(String s) {
        segments = new int[SEG_COUNT];
        dfs(s, 0, 0);
        return ans;
    }

    public void dfs(String s, int segId, int segStart) {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == SEG_COUNT) {
            if (segStart == s.length()) {
                StringBuffer ipAddr = new StringBuffer();
                for (int i = 0; i < SEG_COUNT; ++i) {
                    ipAddr.append(segments[i]);
                    if (i != SEG_COUNT - 1) {
                        ipAddr.append('.');
                    }
                }
                ans.add(ipAddr.toString());
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
        if (segStart == s.length()) {
            return;
        }

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s.charAt(segStart) == '0') {
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int segEnd = segStart; segEnd < s.length(); ++segEnd) {
            addr = addr * 10 + (s.charAt(segEnd) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segments[segId] = addr;
                dfs(s, segId + 1, segEnd + 1);
            } else {
                break;
            }
        }
    }
}

~~~

## 中序遍历

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812082543493.png" alt="image-20210812082543493" style="zoom:50%;" />

~~~ 
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
}
就是递归
~~~

## 交错字符串

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812150006120.png" alt="image-20210812150006120" style="zoom:50%;" />

方法：动态规划，就是一个二维矩阵找路径



<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812151831115.png" alt="image-20210812151831115" style="zoom:50%;" />

~~~ 
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
        if (s3.length() != m + n) return false;
        // 动态规划，dp[i,j]表示s1前i字符能与s2前j字符组成s3前i+j个字符；
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;
        for (int i = 1; i <= m && s1.charAt(i-1) == s3.charAt(i-1); i++) dp[i][0] = true; // 不相符直接终止
        for (int j = 1; j <= n && s2.charAt(j-1) == s3.charAt(j-1); j++) dp[0][j] = true; // 不相符直接终止
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = (dp[i - 1][j] && s3.charAt(i + j - 1) == s1.charAt(i - 1))
                    || (dp[i][j - 1] && s3.charAt(i + j - 1) == s2.charAt(j - 1));
            }
        }
        return dp[m][n];
    }
}
~~~

## 相同二叉树

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812154415798.png" alt="image-20210812154415798" style="zoom:50%;" />

方法：深度优先算法

~~~ 
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null||q==null)return p==q;
        if(p.val!=q.val) return false;
        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}

直接递归就完事了
~~~

# 8、16

## 快排

快排其实也就是分治法，设立一个基准，之后两边各一个指针向中间靠，当左大于基准右小于基准是调换位置

~~~
    public static void quiksort() {
        int[] arr = {1, 5, 6, 7, 8, 4, 2};
        qk(arr, 0, arr.length - 1);
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }

    public static void qk(int[] arr, int left, int right) {
        if (left < right) {
            int index = qk2(arr, left, right);
            qk(arr, left, index - 1);
            qk(arr, index + 1, right);
        }
    }

    public static int qk2(int[] arr, int left, int right) {
        int tmp = arr[left];
        int i = left;
        int j = right;
        while (i != j) {
            while (i < j && arr[j] >= tmp) {
                j--;
            }
            while (i < j && arr[i] <= tmp) {
                i++;
            }
            if (i < j) {
                int buffer = arr[i];
                arr[i] = arr[j];
                arr[j] = buffer;
            }
        }
        arr[left] = arr[j];
        arr[j] = tmp;
        return j;
    }
~~~

## 广度优先搜索

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210816104908984.png" alt="image-20210816104908984" style="zoom:50%;" />

使用到队列queue先进先出，进了之后出记录，接着入左右节点，之后循环直至queue为空

~~~ 
class Solution {000
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        if (root == null) {
            return ret;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> level = new ArrayList<Integer>();
            int currentLevelSize = queue.size();
            //这里需要提前得知queue的size
            for (int i = 1; i <= currentLevelSize; ++i) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            ret.add(level);
        }
        
        return ret;
    }
}

~~~

# 8.17

## 二叉树的深度

方法：就是递归，为空时为0，不为空返回左右大的一个+1

~~~ 
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        } else {
            int leftHeight = maxDepth(root.left);
            int rightHeight = maxDepth(root.right);
            return Math.max(leftHeight, rightHeight) + 1;
        }
    }
}
~~~

## bean的生命周期

实例化 createbeaninstance 就是构造这个bean

属性赋值polulatebean 给其中的值赋值

初始化initializebean （包括多个aware函数和inital函数）

销毁

# 8.18

## 猜数字游戏

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210818092810340.png" alt="image-20210818092810340" style="zoom:50%;" />

方法：

~~~ 
class Solution {
    public String getHint(String secret, String guess) {
        //定义三个数组，hit表示命中（数字相同且位置相同）
        int[] hit = new int[10];
        //secretMiss表示未命中，但在secret字符串中统计该字符
        int[] secretMiss = new int[10];
        //guessMiss表示未命中，但在guess字符串中统计该字符
        int[] guessMiss = new int[10];

        //按照上述方法遍历，各自统计；
        for(int i = 0;i < secret.length();i ++){
            if(secret.charAt(i) == guess.charAt(i)){
                hit[secret.charAt(i)-'0']++;
            }
            else{
                secretMiss[secret.charAt(i)-'0']++;
                guessMiss[guess.charAt(i)-'0']++;
            }
        }
        //bull的数量应是hit数组之和；
        //cow的数量取secretMiss和guessMiss相同位置上较小的数值（因为不能重复计算，所以只能一对一匹配缺失的）。
        int bull = 0,cow = 0;
        for(int i = 0;i < 10;i ++){
            if(hit[i] != 0){
                bull = bull + hit[i];
            }
            cow = cow + Math.min(secretMiss[i],guessMiss[i]);
        }
        //写答案
        StringBuffer sb = new StringBuffer();
        sb.append(String.valueOf(bull));
        sb.append("A");
        sb.append(String.valueOf(cow));
        sb.append("B");

        return sb.toString();
    }
}
~~~

# 8/23

## 多线程

### 继承thread类

run和start区别

run先调用run，run调用完在开始调用其他方法，

start调用时也可以使用其他方法。

线程由cpu调度，而不是谁先调用。

### 实现runnable接口

传入thread

new thread（t1）.start();

可以实现多线程同时操作一个对象！推荐使用runnable

多个线程同时操作一个线程，就会有可能出现线程紊乱。

### 实现callable接口

加上一个返回值主要

# 8/24

## lamda表达式

如果只包含一个抽象方法，那就是函数式接口。

```

public class lamda {
    public static void main(String[] args) {
            Love love=(int a) ->{
                    System.out.println("shuchu-->"+a);
                };
                
                //简化括号
            love=a -> {
                System.out.println("shuchu-->"+a);
            };
            
            //           简化花括号
            love=a ->   System.out.println("shuchu-->"+a);

        love.love(2);
    }
}

interface Love{
    void love(int a );
}
```

## join强制执行，yield线程礼让

## 观测线程状态

Thread.getState

## 设置线程优先级

优先级并不是先高得运行完，还是看cpu调度

## 守护线程

```
public class TestDaem {


    public static void main(String[] args) {
        god god=new god();
        you you=new you();
        Thread thread=new Thread(god);
        thread.setDaemon(true);
//        true,------false是默认的用户线程
        thread.start();
        new Thread(you).start();
    }
}

//你
class you implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i <36500 ; i++) {
            System.out.println("活得的第"+i);
        }
        System.out.println("再见世界！");
    }
}
//上帝
class god implements Runnable{

    @Override
    public void run() {
        while (true){
            System.out.println("上帝保佑你");
        }

    }
}
```

## 线程同步

队列+锁

# 8/25

## 死锁

## lock锁

可重入锁

## ConcurrentHashMap

相较于hashmap加入了segment来分隔空间，分空间进行lock锁，既保证了读写速度也使得线程安全。

## Reentrantlock

## Redis

## 线程池

ThreadPoolExcutor

池化思想

## 线程辅助类

```
CountDownLatch 减法计数器
CyclicBarrier 循环栅栏必须执行到继承结束
Semaphore 信号量 维持一组许可证 限制资源使用 acquire release
```

## 读写锁

readwirtelock

读的时候可以多人读，写的情况下一个人写。

# 8/26

## 阻塞队列

blockingquque

## AQS

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210908095555095.png" alt="image-20210908095555095" style="zoom:33%;" />

## 线程池

池化技术

本质：占用系统资源，优化资源的使用 =>池化技术

池化技术，实现准备好一些资源，有人用，就给他，不用了再还给池子。

### 好处：

提高响应速度，不用创建和销毁。

降低消耗资源

可以控制最大并发数，方便管理

### 三大方法

threadpoolexcutor

```
//        ExecutorService threadPoolExecutor= Executors.newSingleThreadExecutor();
//        ExecutorService threadPoolExecutor2= Executors.newFixedThreadPool(5);
//        ExecutorService threadPoolExecutor3= Executors.newCachedThreadPool();
```

### 七大参数

```
public ThreadPoolExecutor(int corePoolSize,//核心线程多少
                          int maximumPoolSize,//最大核心线程池大小
                          long keepAliveTime,//超时多少没有人调用就是释放
                          TimeUnit unit,//超时单位
                          BlockingQueue<Runnable> workQueue,//阻塞队列
                          ThreadFactory threadFactory,//线程工厂
                          RejectedExecutionHandler handler//拒绝策略
                          ) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

​

最大值为最大核心策略+队列数

```
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
        3,
        5,
        100,
        TimeUnit.SECONDS,
        new LinkedBlockingDeque<>(3),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.AbortPolicy());
```

### 四种拒绝策略

```
AbortPolicy：抛出异常
CallerRunsPolicy：哪里触发线程就回到哪去
DiscardPolicy:不抛出异常，丢掉任务
DiscardOldestPolicy:尝试竞争，不抛出异常。
```

### CPU密集型和IO密集型，关于最大线程定义

```
//获取cpu核数
        
//        System.out.println(Runtime.getRuntime().availableProcessors());
// io十分耗费资源
设置io资源的两倍差不多
```

## jvm

### jvm的位置

系统----》jvm

### jvm体系结构

java-----------classfile-------------》类加载器classloader

### 类的加载过程

<img src="https://images2015.cnblogs.com/blog/907818/201603/907818-20160317231659365-766608088.jpg" alt="img" style="zoom:67%;" />



<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210908084537377.png" alt="image-20210908084537377" style="zoom: 33%;" />

加载：生成一个class对象 -------->生成在方法区--------->形成堆区的对象

链接：分为验证，准备，解析

- **验证：**确保加载的类信息符合JVM规范，没有安全方面的问题

- **准备：**正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法去中进行分配

- **解析：**虚拟机常量池的符号引用替换为字节引用过程

之后就是初始化

被使用

最后卸载

运行时数据区

方法区：运行的构造方法，接口，常量池，静态变量

堆区：实例对象

java栈区：存放一个实例的局部变量链接，方法出口之类的，线程单有的。

本地栈区：本地方法的栈区。

程序计数器：记载下一个方法的地址。

### 类加载

加载class启动器

![image-20210908091439736](C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210908091439736.png)

双亲委派机制：就是会向上找他的根加载器由app---------exc-------boot加载器，直到可以启动类

### native方法区

native方法就是直接调用java底层c语言所写的方法。调用本地栈

### 堆

一个jvm只有一个堆区，分为

新生区：包含Eden和from to

老年区：从新生区活下来的对象

元空间：保存一些常量

问题：OOM堆内存不足

1：首先对jvm堆内存的扩容

2：扩容还不行就用一些插件来帮忙查看哪部分有问题

#### GC常用方法：

标记清除算法：两次扫描，将未标记的对象清楚。

标记压缩算法：两次扫描，将标记的对象放在连续内存上，然后将未标记的清楚。

复制算法：将新生代中的需要保留的复制在from和老年代中，然后删除这些

引用计数算法：将每一个对象使用次数标记，最后将未被使用的删除

#### voilatitle，jmm

保证可见性

不保证原子性//如何保证呢？使用原子类 automicInteger

禁止指令重排// 编译时

> 什么是jmm

jmm:内存模型，约定

线程解锁前必须共享变量刷回主存。

线程加锁钱必须共享变量刷到工作内存中。

加锁解锁必须同一把锁。

## 注解和反射

### 注解

重写注解

### 反射

java是静态语言

## spring

# 8、27

## 事务的原理

> 原子性
>
> undo log保持原子性和一致性//回滚日志



> 持久性
>
> ### Redo log保留回滚的操作//重做日志

> 隔离性
>
> 并发情况下可能会出现三种问题：脏读，不可重复读，幻读

脏读：读到了未提交的事务中改变的数据

不可重复读，读到了已提交的事务中改变的数据

幻读：读到了提交了数据的改变的行内容





> (一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性
> (一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性

事务隔离机制

<img src="https://upload-images.jianshu.io/upload_images/14576226-3cc6fd6ccf77f56a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" />

读未提交完全没有隔离，串行化太浪费资源，大部分是读已提交和可重复读

MVCC

> 一致性

# 8/31

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210831152046288.png" alt="image-20210831152046288" style="zoom:50%;" />

双指针对比就行了

~~~ 
class Solution {
    public boolean isPalindrome(String s) {
        StringBuffer sgood = new StringBuffer();
        int length = s.length();
        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (Character.isLetterOrDigit(ch)) {
                sgood.append(Character.toLowerCase(ch));
            }
        }
        int n = sgood.length();
        int left = 0, right = n - 1;
        while (left < right) {
            if (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) {
                return false;
            }
            ++left;
            --right;
        }
        return true;
    }
}
~~~

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210831153313509.png" alt="image-20210831153313509" style="zoom:50%;" />

算出所有上升期就可以。

~~~ 
class Solution {
   public int maxProfit(int[] arr) {
        if (arr == null || arr.length <= 1) return 0;

        int ans = 0;
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > arr[i-1]) {  // 卖出有利可图
                ans += (arr[i] - arr[i-1]);
            }
        }

        return ans;
    }
}
~~~

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210831153347155.png" alt="image-20210831153347155" style="zoom:50%;" />

这是上面的简化版本，1可以通过两个循环，暴力算出最大差距

2，可以理解为，一段一段的最低与之后的最高相比较

~~~ 
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}
 
~~~

# 9/1

## lock锁与synsynchronized的原理与区别

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210903111749599.png" alt="image-20210903111749599" style="zoom:50%;" />

# 9、6

## http和https

http超文本传输协议

<img src="https://img-blog.csdn.net/20180723105652242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210906141023061.png" alt="image-20210906141023061" style="zoom:50%;" />

## innodb和myisam

### innodb特性：

行锁；

索引是b+树；

支持外键；

支持事务安全；

### myisam特性：

表锁；

不支持外键；

## jmm

<img src="https://pic1.zhimg.com/80/v2-67833188e191c5e7a11d34e613ca352c_1440w.jpg" alt="img" style="zoom:67%;" />

由于内存，高速缓存，和cpu之间得数据交换时会产生数据副本以及，不同线程操作相同变量并不会及时同步到主存中。

可见性：<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210908092733568.png" alt="image-20210908092733568" style="zoom:33%;" />

原子性：

# 9/7

## hashmap原理

```
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;  //哈希值
    final K key;  //键的值
    V value;   //所对值
    Node<K,V> next;  //链表下一个node

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + "=" + value; }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            if (Objects.equals(key, e.getKey()) &&
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
```

### put源码

```
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
	 /**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don't change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; 
	Node<K,V> p; 
	int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
	/*如果table的在（n-1）&hash的值是空，就新建一个节点插入在该位置*/
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
	/*表示有冲突,开始处理冲突*/
        else {
            Node<K,V> e; 
	    K k;
	/*检查第一个Node，p是不是要找的值*/
            if (p.hash == hash &&((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
		/*指针为空就挂在后面*/
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
		       //如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，　　　　　　　　　　　　　
　　　　　　　　　　　　//treeifyBin首先判断当前hashMap的长度，如果不足64，只进行
                        //resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
		/*如果有相同的key值就结束遍历*/
                    if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
	/*就是链表上有相同的key值*/
            if (e != null) { // existing mapping for key，就是key的Value存在
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;//返回存在的Value值
            }
        }
        ++modCount;
     /*如果当前大小大于门限，门限原本是初始容量*0.75*/
        if (++size > threshold)
            resize();//扩容两倍
        afterNodeInsertion(evict);
        return null;
    }
```

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210907085016548.png" alt="image-20210907085016548" style="zoom:50%;" />

	### get的源码

```
public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
	  /**
     * Implements Map.get and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @return the node, or null if none
     */
	final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab;//Entry对象数组
	Node<K,V> first,e; //在tab数组中经过散列的第一个位置
	int n;
	K k;
	/*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) & hash]*/
	//也就是说在一条链上的hash值相同的
        if ((tab = table) != null && (n = tab.length) > 0 &&(first = tab[(n - 1) & hash]) != null) {
	/*检查第一个Node是不是要找的Node*/
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))//判断条件是hash值要相同，key值要相同
                return first;
	  /*检查first后面的node*/
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
				/*遍历后面的链表，找到key值和hash值都相同的Node*/
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
```

## 动态代理

### 静态代理

### 动态代理

底层时反射：

基于接口的动态代理：jdk动态代理

基于类的动态代理：cglib

proxy 代理

invocationhandler 调用 处理程序

每个代理实例都有一个关联的调用处理程序

java通过反射机制在动态代理类中代理类，并且可以增强功能。

# 9、16

# 3、14

# 8.16
