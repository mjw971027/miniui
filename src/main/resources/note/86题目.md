# 8/6题目

## 螺旋矩阵

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806104725930.png" alt="image-20210806104725930" style="zoom:50%;" />

方法：模拟

> 生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：
> 定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n * n；
> 当 num <= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：
> 执行 num += 1：得到下一个需要填入的数字；
> 更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。
> 使用num <= tar而不是l < r || t < b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。

```java
public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int up = 0, down = n - 1, left = 0, right = n - 1, index = 1;
        while(index <= n * n){
            for(int i = left; i <= right; i++){
                res[up][i] = index++;
            }
            up++;
            for(int i = up; i <= down; i++){
                res[i][right] = index++;
            }
            right--;
            for(int i = right; i >= left; i--){
                res[down][i] = index++;
            }
            down--;
            for(int i = down; i >= up; i--){
                res[i][left] = index++;
            }
            left++;
        }
        return res;
    }
```

## 排列排序

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806105551154.png" alt="image-20210806105551154" style="zoom:50%;" />'
.'

方法：数学方法

## 旋转链表

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806110603824.png" alt="image-20210806110603824" style="zoom: 50%;" />

方法：闭合为环

~~~java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        if (k == 0 || head == null || head.next == null) {
            return head;
        }
        int n = 1;
        ListNode iter = head;
        while (iter.next != null) {
            iter = iter.next;
            n++;
        }
        int add = n - k % n;
        if (add == n) {
            return head;
        }
        iter.next = head;
        while (add-- > 0) {
            iter = iter.next;
        }
        ListNode ret = iter.next;
        iter.next = null;
        return ret;
    }
}

~~~

## 不同路径

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806111018183.png" alt="image-20210806111018183" style="zoom:50%;" />

方法：动态规划

f(m,n)=f(m-1,n)+f(m,n-1)

之后就类似斐波那契数列的处理。

~~~ java
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        for (int i = 0; i < m; ++i) {
            f[i][0] = 1;
        }
        for (int j = 0; j < n; ++j) {
            f[0][j] = 1;
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
}
~~~

## 不同路径2号

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806113435057.png" alt="image-20210806113435057" style="zoom:50%;" />

就是在一号的基础上吧f（k,j）位置为0

~~~ java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n = obstacleGrid.length, m = obstacleGrid[0].length;
        int[] f = new int[m];

        f[0] = obstacleGrid[0][0] == 0 ? 1 : 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    f[j] = 0;
                    continue;
                }
                if (j - 1 >= 0 && obstacleGrid[i][j - 1] == 0) {
                    f[j] += f[j - 1];
                }
            }
        }
        
        return f[m - 1];
    }
}

~~~

## 最小路径和

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806130257943.png" alt="image-20210806130257943" style="zoom:50%;" />

方法：动态规划

~~~java
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rows = grid.length, columns = grid[0].length;
        int[][] dp = new int[rows][columns];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < columns; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < columns; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[rows - 1][columns - 1];
    }
}


~~~

## 矩阵置零

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210806144640211.png" alt="image-20210806144640211" style="zoom:50%;" />

方法：各用一个数组表现行与列的布尔值

```
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = col[j] = true;
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] || col[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

# 8/9题目

## 最小覆盖子串

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210809094100760.png" alt="image-20210809094100760" style="zoom:50%;" />

方法：滑动窗口

```  java
class Solution {
    Map<Character, Integer> ori = new HashMap<Character, Integer>();
    Map<Character, Integer> cnt = new HashMap<Character, Integer>();

    public String minWindow(String s, String t) {
        int tLen = t.length();
        for (int i = 0; i < tLen; i++) {
            char c = t.charAt(i);
            ori.put(c, ori.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;
        int sLen = s.length();
        while (r < sLen) {
            ++r;
            if (r < sLen && ori.containsKey(s.charAt(r))) {
                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);
            }
            while (check() && l <= r) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                if (ori.containsKey(s.charAt(l))) {
                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);
                }
                ++l;
            }
        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    public boolean check() {
        Iterator iter = ori.entrySet().iterator(); 
        while (iter.hasNext()) { 
            Map.Entry entry = (Map.Entry) iter.next(); 
            Character key = (Character) entry.getKey(); 
            Integer val = (Integer) entry.getValue(); 
            if (cnt.getOrDefault(key, 0) < val) {
                return false;
            }
        } 
        return true;
    }
}
```

## 组合

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210809094325149.png" alt="image-20210809094325149" style="zoom:50%;" />

方法：

``` 
class Solution {
    List<Integer> temp = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> combine(int n, int k) {
        dfs(1, n, k);
        return ans;
    }

    public void dfs(int cur, int n, int k) {
        // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp
        if (temp.size() + (n - cur + 1) < k) {
            return;
        }
        // 记录合法的答案
        if (temp.size() == k) {
            ans.add(new ArrayList<Integer>(temp));
            return;
        }
        // 考虑选择当前位置
        temp.add(cur);
        dfs(cur + 1, n, k);
        temp.remove(temp.size() - 1);
        // 考虑不选择当前位置
        dfs(cur + 1, n, k);
    }
}

```

## 子集问题

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210809095606082.png" alt="image-20210809095606082" style="zoom:50%;" />

方法：还是回溯法和全排列有些像

~~~ 
class Solution {
   public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        dfs(nums, 0, nums.length, path, res);
        return res;
    }

    private void dfs(int[] nums, int begin, int n, List<Integer> path, List<List<Integer>> res) {
        res.add(new ArrayList<>(path));
        for (int i=begin; i<n; i++) {
            path.add(nums[i]);
            dfs(nums, i+1, n, path, res);
            path.remove(path.size()-1);
        }
    }
}
~~~

### 回溯法有个模板

即：

``` 
List<List<Integer>> result = new ArrayList<>();
void backtrack(路径,选择列表){
    if(符合结束条件){
        result.push_back(路径);
        return;
    }
    for(选择 : 选择列表){
        做选择;路径增加选择;选择列表删除选择;
        backtrack(路径,选择列表);
        撤销选择;路径取消选择;选择列表添加选择;
    }
}
```

# 8/11

## 子集Ⅱ

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210811091627188.png" alt="image-20210811091627188" style="zoom:50%;" />

相比与普通求子集，就是去除了重复部分 在当前位置的数若是与上一个数相同，则不加入跳过。

~~~ 
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        dfs(false, 0, nums);
        return ans;
    }

    public void dfs(boolean choosePre, int cur, int[] nums) {
        if (cur == nums.length) {
            ans.add(new ArrayList<Integer>(t));
            return;
        }
        dfs(false, cur + 1, nums);
        if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {
            return;
        }
        t.add(nums[cur]);
        dfs(true, cur + 1, nums);
        t.remove(t.size() - 1);
    }
}
~~~

# 8/12

## 复原ip地址

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812082233473.png" alt="image-20210812082233473" style="zoom:50%;" />

方法：回溯法，暴力解法

``` 
1.暴力解法：
class Solution {
    public List<String> restoreIpAddresses(String s) {
        List<String> list = new ArrayList();
        for(int a=1; a<4; a++){
            for(int b=1; b<4; b++){
                for(int c=1; c<4; c++){
                    for(int d=1; d<4; d++){
                        if(a+b+c+d==s.length()){
                            String s1 = s.substring(0, a);
                            String s2 = s.substring(a, a+b);
                            String s3 = s.substring(a+b, a+b+c);
                            String s4 = s.substring(a+b+c, a+b+c+d);

                            if(check(s1)&&check(s2)&&check(s3)&&check(s4)){
                                String ip = s1+"."+s2+"."+s3+"."+s4;
                                list.add(ip);
                            }
                        }
                    }
                }
            }
        }
        return list;
    }

    public boolean check(String s){
        if(Integer.valueOf(s)<=255){
            if(s.charAt(0)!='0' || s.charAt(0)=='0'&&s.length()==1) 
                return true;
        }
        return false;
    }
}
```

~~~ java
2.回溯法
class Solution {
    static final int SEG_COUNT = 4;
    List<String> ans = new ArrayList<String>();
    int[] segments = new int[SEG_COUNT];

    public List<String> restoreIpAddresses(String s) {
        segments = new int[SEG_COUNT];
        dfs(s, 0, 0);
        return ans;
    }

    public void dfs(String s, int segId, int segStart) {
        // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案
        if (segId == SEG_COUNT) {
            if (segStart == s.length()) {
                StringBuffer ipAddr = new StringBuffer();
                for (int i = 0; i < SEG_COUNT; ++i) {
                    ipAddr.append(segments[i]);
                    if (i != SEG_COUNT - 1) {
                        ipAddr.append('.');
                    }
                }
                ans.add(ipAddr.toString());
            }
            return;
        }

        // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯
        if (segStart == s.length()) {
            return;
        }

        // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0
        if (s.charAt(segStart) == '0') {
            segments[segId] = 0;
            dfs(s, segId + 1, segStart + 1);
        }

        // 一般情况，枚举每一种可能性并递归
        int addr = 0;
        for (int segEnd = segStart; segEnd < s.length(); ++segEnd) {
            addr = addr * 10 + (s.charAt(segEnd) - '0');
            if (addr > 0 && addr <= 0xFF) {
                segments[segId] = addr;
                dfs(s, segId + 1, segEnd + 1);
            } else {
                break;
            }
        }
    }
}

~~~

## 中序遍历

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812082543493.png" alt="image-20210812082543493" style="zoom:50%;" />

~~~ 
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
}
就是递归
~~~

## 交错字符串

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812150006120.png" alt="image-20210812150006120" style="zoom:50%;" />

方法：动态规划，就是一个二维矩阵找路径



<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812151831115.png" alt="image-20210812151831115" style="zoom:50%;" />

~~~ 
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
        if (s3.length() != m + n) return false;
        // 动态规划，dp[i,j]表示s1前i字符能与s2前j字符组成s3前i+j个字符；
        boolean[][] dp = new boolean[m+1][n+1];
        dp[0][0] = true;
        for (int i = 1; i <= m && s1.charAt(i-1) == s3.charAt(i-1); i++) dp[i][0] = true; // 不相符直接终止
        for (int j = 1; j <= n && s2.charAt(j-1) == s3.charAt(j-1); j++) dp[0][j] = true; // 不相符直接终止
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = (dp[i - 1][j] && s3.charAt(i + j - 1) == s1.charAt(i - 1))
                    || (dp[i][j - 1] && s3.charAt(i + j - 1) == s2.charAt(j - 1));
            }
        }
        return dp[m][n];
    }
}
~~~

## 相同二叉树

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210812154415798.png" alt="image-20210812154415798" style="zoom:50%;" />

方法：深度优先算法

~~~ 
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null||q==null)return p==q;
        if(p.val!=q.val) return false;
        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);
    }
}

直接递归就完事了
~~~

# 8、16

## 快排

快排其实也就是分治法，设立一个基准，之后两边各一个指针向中间靠，当左大于基准右小于基准是调换位置

~~~
    public static void quiksort() {
        int[] arr = {1, 5, 6, 7, 8, 4, 2};
        qk(arr, 0, arr.length - 1);
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }

    public static void qk(int[] arr, int left, int right) {
        if (left < right) {
            int index = qk2(arr, left, right);
            qk(arr, left, index - 1);
            qk(arr, index + 1, right);
        }
    }

    public static int qk2(int[] arr, int left, int right) {
        int tmp = arr[left];
        int i = left;
        int j = right;
        while (i != j) {
            while (i < j && arr[j] >= tmp) {
                j--;
            }
            while (i < j && arr[i] <= tmp) {
                i++;
            }
            if (i < j) {
                int buffer = arr[i];
                arr[i] = arr[j];
                arr[j] = buffer;
            }
        }
        arr[left] = arr[j];
        arr[j] = tmp;
        return j;
    }
~~~

## 广度优先搜索

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210816104908984.png" alt="image-20210816104908984" style="zoom:50%;" />

使用到队列queue先进先出，进了之后出记录，接着入左右节点，之后循环直至queue为空

~~~ 
class Solution {000
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        if (root == null) {
            return ret;
        }

        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> level = new ArrayList<Integer>();
            int currentLevelSize = queue.size();
            //这里需要提前得知queue的size
            for (int i = 1; i <= currentLevelSize; ++i) {
                TreeNode node = queue.poll();
                level.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            ret.add(level);
        }
        
        return ret;
    }
}

~~~

# 8.17

## 二叉树的深度

方法：就是递归，为空时为0，不为空返回左右大的一个+1

~~~ 
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        } else {
            int leftHeight = maxDepth(root.left);
            int rightHeight = maxDepth(root.right);
            return Math.max(leftHeight, rightHeight) + 1;
        }
    }
}
~~~

## bean的生命周期

实例化 createbeaninstance 就是构造这个bean

属性赋值polulatebean 给其中的值赋值

初始化initializebean （包括多个aware函数和inital函数）

销毁

# 8.18

## 猜数字游戏

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210818092810340.png" alt="image-20210818092810340" style="zoom:50%;" />

方法：

~~~ 
class Solution {
    public String getHint(String secret, String guess) {
        //定义三个数组，hit表示命中（数字相同且位置相同）
        int[] hit = new int[10];
        //secretMiss表示未命中，但在secret字符串中统计该字符
        int[] secretMiss = new int[10];
        //guessMiss表示未命中，但在guess字符串中统计该字符
        int[] guessMiss = new int[10];

        //按照上述方法遍历，各自统计；
        for(int i = 0;i < secret.length();i ++){
            if(secret.charAt(i) == guess.charAt(i)){
                hit[secret.charAt(i)-'0']++;
            }
            else{
                secretMiss[secret.charAt(i)-'0']++;
                guessMiss[guess.charAt(i)-'0']++;
            }
        }
        //bull的数量应是hit数组之和；
        //cow的数量取secretMiss和guessMiss相同位置上较小的数值（因为不能重复计算，所以只能一对一匹配缺失的）。
        int bull = 0,cow = 0;
        for(int i = 0;i < 10;i ++){
            if(hit[i] != 0){
                bull = bull + hit[i];
            }
            cow = cow + Math.min(secretMiss[i],guessMiss[i]);
        }
        //写答案
        StringBuffer sb = new StringBuffer();
        sb.append(String.valueOf(bull));
        sb.append("A");
        sb.append(String.valueOf(cow));
        sb.append("B");

        return sb.toString();
    }
}
~~~

# 8/23

## 多线程

### 继承thread类

run和start区别

run先调用run，run调用完在开始调用其他方法，

start调用时也可以使用其他方法。

线程由cpu调度，而不是谁先调用。

### 实现runnable接口

传入thread

new thread（t1）.start();

可以实现多线程同时操作一个对象！推荐使用runnable

多个线程同时操作一个线程，就会有可能出现线程紊乱。

### 实现callable接口

加上一个返回值主要

# 8/24

## lamda表达式

如果只包含一个抽象方法，那就是函数式接口。

```

public class lamda {
    public static void main(String[] args) {
            Love love=(int a) ->{
                    System.out.println("shuchu-->"+a);
                };
                
                //简化括号
            love=a -> {
                System.out.println("shuchu-->"+a);
            };
            
            //           简化花括号
            love=a ->   System.out.println("shuchu-->"+a);

        love.love(2);
    }
}

interface Love{
    void love(int a );
}
```

## join强制执行，yield线程礼让

## 观测线程状态

Thread.getState

## 设置线程优先级

优先级并不是先高得运行完，还是看cpu调度

## 守护线程

```
public class TestDaem {


    public static void main(String[] args) {
        god god=new god();
        you you=new you();
        Thread thread=new Thread(god);
        thread.setDaemon(true);
//        true,------false是默认的用户线程
        thread.start();
        new Thread(you).start();
    }
}

//你
class you implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i <36500 ; i++) {
            System.out.println("活得的第"+i);
        }
        System.out.println("再见世界！");
    }
}
//上帝
class god implements Runnable{

    @Override
    public void run() {
        while (true){
            System.out.println("上帝保佑你");
        }

    }
}
```

## 线程同步

队列+锁

# 8/25

## 死锁

## lock锁

可重入锁

## ConcurrentHashMap

相较于hashmap加入了segment来分隔空间，分空间进行lock锁，既保证了读写速度也使得线程安全。

## Reentrantlock

## Redis

## 线程池

ThreadPoolExcutor

池化思想

## 线程辅助类

```
CountDownLatch 减法计数器
CyclicBarrier 循环栅栏必须执行到继承结束
Semaphore 信号量 维持一组许可证 限制资源使用 acquire release
```

## 读写锁

readwirtelock

读的时候可以多人读，写的情况下一个人写。

# 8/26

## 阻塞队列

blockingquque

## AQS

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210908095555095.png" alt="image-20210908095555095" style="zoom:33%;" />

## 线程池

池化技术

本质：占用系统资源，优化资源的使用 =>池化技术

池化技术，实现准备好一些资源，有人用，就给他，不用了再还给池子。

### 好处：

提高响应速度，不用创建和销毁。

降低消耗资源

可以控制最大并发数，方便管理

### 三大方法

threadpoolexcutor

```
//        ExecutorService threadPoolExecutor= Executors.newSingleThreadExecutor();
//        ExecutorService threadPoolExecutor2= Executors.newFixedThreadPool(5);
//        ExecutorService threadPoolExecutor3= Executors.newCachedThreadPool();
```

### 七大参数

```
public ThreadPoolExecutor(int corePoolSize,//核心线程多少
                          int maximumPoolSize,//最大核心线程池大小
                          long keepAliveTime,//超时多少没有人调用就是释放
                          TimeUnit unit,//超时单位
                          BlockingQueue<Runnable> workQueue,//阻塞队列
                          ThreadFactory threadFactory,//线程工厂
                          RejectedExecutionHandler handler//拒绝策略
                          ) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
            null :
            AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```



最大值为最大核心策略+队列数

```
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
        3,
        5,
        100,
        TimeUnit.SECONDS,
        new LinkedBlockingDeque<>(3),
        Executors.defaultThreadFactory(),
        new ThreadPoolExecutor.AbortPolicy());
```

### 四种拒绝策略

```
AbortPolicy：抛出异常
CallerRunsPolicy：哪里触发线程就回到哪去
DiscardPolicy:不抛出异常，丢掉任务
DiscardOldestPolicy:尝试竞争，不抛出异常。
```

### CPU密集型和IO密集型，关于最大线程定义

```
//获取cpu核数
        
//        System.out.println(Runtime.getRuntime().availableProcessors());
// io十分耗费资源
设置io资源的两倍差不多
```

## jvm

### jvm的位置

系统----》jvm

### jvm体系结构

java-----------classfile-------------》类加载器classloader

### 类的加载过程

<img src="https://images2015.cnblogs.com/blog/907818/201603/907818-20160317231659365-766608088.jpg" alt="img" style="zoom:67%;" />



<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210908084537377.png" alt="image-20210908084537377" style="zoom: 33%;" />

加载：生成一个class对象 -------->生成在方法区--------->形成堆区的对象

链接：分为验证，准备，解析

- **验证：**确保加载的类信息符合JVM规范，没有安全方面的问题

- **准备：**正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法去中进行分配

- **解析：**虚拟机常量池的符号引用替换为字节引用过程

之后就是初始化

被使用

最后卸载

运行时数据区

方法区：运行的构造方法，接口，常量池，静态变量

堆区：实例对象

java栈区：存放一个实例的局部变量链接，方法出口之类的，线程单有的。

本地栈区：本地方法的栈区。

程序计数器：记载下一个方法的地址。

### 类加载

加载class启动器

![image-20210908091439736](C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210908091439736.png)

双亲委派机制：就是会向上找他的根加载器由app---------exc-------boot加载器，直到可以启动类

### native方法区

native方法就是直接调用java底层c语言所写的方法。调用本地栈

### 堆

一个jvm只有一个堆区，分为

新生区：包含Eden和from to

老年区：从新生区活下来的对象

元空间：保存一些常量

问题：OOM堆内存不足

1：首先对jvm堆内存的扩容

2：扩容还不行就用一些插件来帮忙查看哪部分有问题

#### GC常用方法：

标记清除算法：两次扫描，将未标记的对象清楚。

标记压缩算法：两次扫描，将标记的对象放在连续内存上，然后将未标记的清楚。

复制算法：将新生代中的需要保留的复制在from和老年代中，然后删除这些

引用计数算法：将每一个对象使用次数标记，最后将未被使用的删除

#### voilatitle，jmm

保证可见性

不保证原子性//如何保证呢？使用原子类 automicInteger

禁止指令重排// 编译时

> 什么是jmm

jmm:内存模型，约定

线程解锁前必须共享变量刷回主存。

线程加锁钱必须共享变量刷到工作内存中。

加锁解锁必须同一把锁。

## 注解和反射

### 注解

重写注解

### 反射

java是静态语言

## spring

# 8、27

## 事务的原理

> 原子性
>
> undo log保持原子性和一致性//回滚日志



> 持久性
>
> ### Redo log保留回滚的操作//重做日志

> 隔离性
>
> 并发情况下可能会出现三种问题：脏读，不可重复读，幻读

脏读：读到了未提交的事务中改变的数据

不可重复读，读到了已提交的事务中改变的数据

幻读：读到了提交了数据的改变的行内容





> (一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性
> (一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性

事务隔离机制

<img src="https://upload-images.jianshu.io/upload_images/14576226-3cc6fd6ccf77f56a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:50%;" />

读未提交完全没有隔离，串行化太浪费资源，大部分是读已提交和可重复读

MVCC

> 一致性

# 8/31

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210831152046288.png" alt="image-20210831152046288" style="zoom:50%;" />

双指针对比就行了

~~~ 
class Solution {
    public boolean isPalindrome(String s) {
        StringBuffer sgood = new StringBuffer();
        int length = s.length();
        for (int i = 0; i < length; i++) {
            char ch = s.charAt(i);
            if (Character.isLetterOrDigit(ch)) {
                sgood.append(Character.toLowerCase(ch));
            }
        }
        int n = sgood.length();
        int left = 0, right = n - 1;
        while (left < right) {
            if (Character.toLowerCase(sgood.charAt(left)) != Character.toLowerCase(sgood.charAt(right))) {
                return false;
            }
            ++left;
            --right;
        }
        return true;
    }
}
~~~

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210831153313509.png" alt="image-20210831153313509" style="zoom:50%;" />

算出所有上升期就可以。

~~~ 
class Solution {
   public int maxProfit(int[] arr) {
        if (arr == null || arr.length <= 1) return 0;

        int ans = 0;
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > arr[i-1]) {  // 卖出有利可图
                ans += (arr[i] - arr[i-1]);
            }
        }

        return ans;
    }
}
~~~

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210831153347155.png" alt="image-20210831153347155" style="zoom:50%;" />

这是上面的简化版本，1可以通过两个循环，暴力算出最大差距

2，可以理解为，一段一段的最低与之后的最高相比较

~~~ 
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice) {
                minprice = prices[i];
            } else if (prices[i] - minprice > maxprofit) {
                maxprofit = prices[i] - minprice;
            }
        }
        return maxprofit;
    }
}
 
~~~

# 9/1

## lock锁与synsynchronized的原理与区别

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210903111749599.png" alt="image-20210903111749599" style="zoom:50%;" />

# 9、6

## http和https

http超文本传输协议

<img src="https://img-blog.csdn.net/20180723105652242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9taW5nMTAwMDAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210906141023061.png" alt="image-20210906141023061" style="zoom:50%;" />

## innodb和myisam

### innodb特性：

行锁；

索引是b+树；

支持外键；

支持事务安全；

### myisam特性：

表锁；

不支持外键；

## jmm

<img src="https://pic1.zhimg.com/80/v2-67833188e191c5e7a11d34e613ca352c_1440w.jpg" alt="img" style="zoom:67%;" />

由于内存，高速缓存，和cpu之间得数据交换时会产生数据副本以及，不同线程操作相同变量并不会及时同步到主存中。

可见性：<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210908092733568.png" alt="image-20210908092733568" style="zoom:33%;" />

原子性：

# 9/7

## hashmap原理

```
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;  //哈希值
    final K key;  //键的值
    V value;   //所对值
    Node<K,V> next;  //链表下一个node

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + "=" + value; }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            if (Objects.equals(key, e.getKey()) &&
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
```

### put源码

```
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
	 /**
     * Implements Map.put and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @param value the value to put
     * @param onlyIfAbsent if true, don't change existing value
     * @param evict if false, the table is in creation mode.
     * @return previous value, or null if none
     */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; 
	Node<K,V> p; 
	int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
	/*如果table的在（n-1）&hash的值是空，就新建一个节点插入在该位置*/
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
	/*表示有冲突,开始处理冲突*/
        else {
            Node<K,V> e; 
	    K k;
	/*检查第一个Node，p是不是要找的值*/
            if (p.hash == hash &&((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
                for (int binCount = 0; ; ++binCount) {
		/*指针为空就挂在后面*/
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
		       //如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，　　　　　　　　　　　　　
　　　　　　　　　　　　//treeifyBin首先判断当前hashMap的长度，如果不足64，只进行
                        //resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
		/*如果有相同的key值就结束遍历*/
                    if (e.hash == hash &&((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
	/*就是链表上有相同的key值*/
            if (e != null) { // existing mapping for key，就是key的Value存在
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;//返回存在的Value值
            }
        }
        ++modCount;
     /*如果当前大小大于门限，门限原本是初始容量*0.75*/
        if (++size > threshold)
            resize();//扩容两倍
        afterNodeInsertion(evict);
        return null;
    }
```

<img src="C:\Users\mjw\AppData\Roaming\Typora\typora-user-images\image-20210907085016548.png" alt="image-20210907085016548" style="zoom:50%;" />

	### get的源码

```
public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }
	  /**
     * Implements Map.get and related methods
     *
     * @param hash hash for key
     * @param key the key
     * @return the node, or null if none
     */
	final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab;//Entry对象数组
	Node<K,V> first,e; //在tab数组中经过散列的第一个位置
	int n;
	K k;
	/*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) & hash]*/
	//也就是说在一条链上的hash值相同的
        if ((tab = table) != null && (n = tab.length) > 0 &&(first = tab[(n - 1) & hash]) != null) {
	/*检查第一个Node是不是要找的Node*/
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))//判断条件是hash值要相同，key值要相同
                return first;
	  /*检查first后面的node*/
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
				/*遍历后面的链表，找到key值和hash值都相同的Node*/
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
```

## 动态代理

### 静态代理

### 动态代理

底层时反射：

基于接口的动态代理：jdk动态代理

基于类的动态代理：cglib

proxy 代理

invocationhandler 调用 处理程序

每个代理实例都有一个关联的调用处理程序

java通过反射机制在动态代理类中代理类，并且可以增强功能。

#  

#   

# 8月

## rabiitmq

## mybatis原理

首先非池化datascore还是用jdbc的DriverManager.getConnection(this.url, properties);来初始化一个connection连接数据库

![mybatis.png](https://img-blog.csdnimg.cn/img_convert/7c0470f4861c4dfb8ce32687c0e40834.png)

1）读取MyBatis的配置文件。mybatis-config.xml为MyBatis的全局配置文件，用于配置数据库连接信息。

（2）加载映射文件。映射文件即SQL映射文件，该文件中配置了操作数据库的SQL语句，需要在MyBatis配置文件mybatis-config.xml中加载。mybatis-config.xml
文件可以加载多个映射文件，每个文件对应数据库中的一张表。

（3）构造会话工厂。通过MyBatis的环境配置信息构建会话工厂[SqlSessionFactory](https://so.csdn.net/so/search?q=SqlSessionFactory&spm=1001.2101.3001.7020)
。

（4）创建会话对象。由会话工厂创建SqlSession对象，该对象中包含了执行SQL语句的所有方法。

（5）Executor执行器。MyBatis底层定义了一个Executor接口来操作数据库，它将根据SqlSession传递的参数动态地生成需要执行的SQL语句，同时负责查询缓存的维护。

（6）MappedStatement对象。在Executor接口的执行方法中有一个MappedStatement类型的参数，该参数是对映射信息的封装，用于存储要映射的SQL语句的id、参数等信息。

（7）输入参数映射。输入参数类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输入参数映射过程类似于JDBC对preparedStatement对象设置参数的过程。

（8）输出结果映射。输出结果类型可以是Map、List等集合类型，也可以是基本数据类型和POJO类型。输出结果映射过程类似于JDBC对结果集的解析过程。

## spring原理

aop和ioc

ioc时applicationconnet

aop时

## java的几个集合类型

list/map/set

## spring的aop怎么实现的

CGLIB是通过父子类

生成类的代理子类

```java
子类（）{

	父类 target

	public void test(){

	@before先执行切面

		target.test();

}}
```

## configuration的作用

生成一个代理对象

## 三级缓存解决循环依赖

1.单例池 singletonobjects

2.earlysingletonobjects

3.singletonFactories

Abean周期：

1.创建对象

2.依赖注入（属性填充---->在单例池singletonObjects中寻找------->创建bservice的对象----->走到最前面找Aservice

3.初始化前填充其他属性

4.初始化

5.初始化后（aop

6.代理对象

7.放入单例池

Bbean周期：

1.创建对象

2.依赖注入（属性填充---->在单例池singletonObjects中寻找------->创建Aservice的对象----->走到最前面找Bservice

3.初始化前填充其他属性

4.初始化

5.初始化后（aop

6.代理对象

7.放入单例池

先将A放入singletonfactories 后发现需要b，

将b放入singletonfactories

之后发现b需要A，然后将A放入earlysingletonobjects

在之后将A（没完全实例化 ）注入到b中，将b放入最后的singletonobjects

将初始化好的b注入到A中，A放入singletonobjects

## springmvc底层原理

dispatcherservlet

![img](https://img2018.cnblogs.com/blog/1338162/201901/1338162-20190113192808388-307235311.png)

## 两种单例模式的区别

单例模式：只能产生一个实例

1.懒汉模式

2.饿汉模式

对象创建的时间。懒汉模式在类加载时，就创建了对象，饿汉模式在外部类需要获取这个对象时，才去创建该对象。

```java
    // 私有的默认构造子，保证外界无法直接实例化  
    private EagerSingleton() {  
    }  

    // 提供全局访问点获取唯一的实例  
    public static EagerSingleton getInstance() {  
            return uniqueInstance;  
    }  饿汉
```

```
    private LazySingleton() {  
    }  

    public static synchronized LazySingleton getInstance() {  
            if (uniqueInstance == null)  
                    uniqueInstance = new LazySingleton();  
            return uniqueInstance;  
    }  懒汉
```

## java三种集合

collection类和map类

collection包括set，list，queue

![img](https://img-blog.csdnimg.cn/7bd4146442a34051a7eb95c3044442f0.png)

![img](https://img-blog.csdnimg.cn/b40b1db591e24c8db40ded75b2f6c282.png)

## List

（1）ArrayList、LinkedList的异同：二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优先于LinkedList,因为LinkedList要移动指针。对于新增和删除操作add(
特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。

（2）ArrayList和Vector的区别：ArrayList和Vector几乎是完全相同的，唯一的区别是在于Vector是同步类（synchronized)
,属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下，大多数的程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的两倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。

list.get()的结果是object

## SET

HASHSET会自动扩容，超过75%就会自动扩容2倍

linkhashset 是hashset的主类，插入顺序保存，效率低于hashset。

treeset

## Map

hashmap无序，hashtable线程安全，自动扩容和set一样；

## 发现synchronized放在while外和while内不一样的结果

1，synchronized放在while外会让while一直被第一个拿到权限的线程不停循环，因为while没完。

2.反之则能正常竞争

## springboot启动流程

1通过@SpringBootApplication注解下的run

2进入到run中创建返回一个新的SpringApplication类

3SpringApplication 用webApplicationType推测使用web类型应用是否是servlet或者是none和reactive

4加载springboot自带的初始化器

5初始化器也可以自己定义

6加载所有的监听器 同样可以监听器

7推断出主类然后运行主类

8接下来进入run程序

9开启计时器进行计时

10.启用监听器

11.准备运行环境

12.打印banner

13.创建上下文

14.实例化异常报告器

15.准备上下文环境

16.刷新上下文

17.完成上下文后置处理afterrefresh

18.调用 callRunners（）两个可以自定义的run方法 ApplicationRunner ，CommandLineRunner

## GC

标记清除算法：两次扫描，将未标记的对象清楚。

标记压缩算法：两次扫描，将标记的对象放在连续内存上，然后将未标记的清楚。

复制算法：将新生代中的需要保留的复制在from和老年代中，然后删除这些

引用计数算法：将每一个对象使用次数标记，最后将未被使用的删除

引用计数不够精确，循环引用就无法判断是否垃圾

标记清除化，容易碎片化

复制算法：浪费空间

标记压缩算法：时间长

java分两类：

分代：老年代，年轻代

分区：一个一个小区

分代：

年轻代：新生的进入年轻代，活得次数多，进入老年代，采用复制算法

年轻代有两个survivor区 现在s1后到S2循环往复，时间长了就到老年代

老年代：采用MC和MS

CMS是标记清除法：用于老年代，可以与执行线程并发处理，不会造成parnew那样的大卡顿，就是为了减少卡顿而生

G1

## 垃圾回收器

![Java 常见的垃圾回收器_https://mp.weixin.qq](https://s2.51cto.com/images/blog/202106/09/79d129f292efb64b2726e6bce6d06ae4.jpg?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

两个互相连线代表可以一起使用

### serial （连续式）

新生代的复制算法回收器，阻塞运行线程的。

![Java 常见的垃圾回收器_https://mp.weixin.qq_03](https://s2.51cto.com/images/blog/202106/09/5c90c1ad1e80d75ef8cba6cd1f9b39b6.jpg?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

### parallel scavenge （并行扫描）

新生代回收器，复制算法，可以自适应调整，提供最大吞吐量，可以牺牲stw时间长，来换大吞吐量，可以进行自动调节新生代老年代的大小，进入老年代的大小。

### parnew （同新式）

新生代复制算法就是serial多线程版本，并行版本。

![Java 常见的垃圾回收器_https://mp.weixin.qq_02](https://s2.51cto.com/images/blog/202106/09/64c816976c18454d35421d87ceb64df9.jpg?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

### parallel old（老年代版本）

保证吞吐量的parallel 老年代版本，并行。

### serial old(连续的老年版本)

新生代的复制算法回收器，阻塞运行线程的。

### CMS

老年代标记清除法，就是要减少停顿时间，会有内存碎片化。产生的stw非常少，但是可能会产生很多碎片空间，追求的是短停顿时间。

1.初始标记(CMS-initial-mark) ,会导致stw;
2.并发标记(CMS-concurrent-mark)，与用户线程同时运行；
3.重新标记(CMS-remark) ，会导致swt；
4.并发清除(CMS-concurrent-sweep)，与用户线程同时运行；
5.并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；

![Java 常见的垃圾回收器_https://mp.weixin.qq_05](https://s2.51cto.com/images/blog/202106/09/0860a5fa4429f221903393eba5dc4b2d.jpg?x-oss-process=image/watermark,size_14,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=)

### G1

本质上是一个分带垃圾回收器。 Garbage First 垃圾回收器相对 CMS 垃圾回收器，有两个改进：

基于标记-整理 算法，不产生内存碎片。

可以准确的控制停顿时间，在不牺牲吞吐的情况下实现低停顿的垃圾回收。

G1 为了避免全区域垃圾收集，把堆内存划分为大小固定的几个独立区域，并跟踪这些区域的回收进度。同时在后台维护一个优先列表，每次根据收集时间的，优先回收垃圾最多的区域。

G1 引入了额外的概念，Region。G1垃圾回收器把堆划分成一个个大小相同的Region。在HotSpot的实现中，整个堆被划分成2048左右个Region。每个Region的大小在1-32MB之间，具体多大取决于堆的大小。

G1垃圾回收器的分代也是建立在这些Region的基础上的。对于Region来说，它会有一个分代的类型，并且是唯一一个。即，每一个Region，它要么是young的，要么是old的。还有一类十分特殊的Humongous。所谓的Humongous，就是一个对象的大小超过了某一个阈值——HotSpot中是Region的1/2，那么它会被标记为Humongous。如果我们审视HotSpot的其余的垃圾回收器，可以发现这种对象以前被称为大对象，会被直接分配老年代。而在G1回收器中，则是做了特殊的处理。

## spring ioc原理

就是控制反转，将对象由容器控制，而不是开发者创建。

容器的创建过程：就是从bean的生命周期讲一下

## srping ioc底层实现

反射来创建bean，工厂模式来获取bean，

1.通过createbeanFactory返回一个DefaultListableBeanFactory

2.通过getbeanFactory实现返回一个beanfactory

3.找到xml或者注解生成beandefinition

4.因为bean都是单例的所以循环创建bean，先通过getbean和dogetbean来寻找bean如果不存在就创建bean

5.之后对bean进行对象填充pupulateBean

6.进行其他初始化操作（initalizationBean

## spring bean注册方式

1.xml注册方式

2.@conpoment+@scan

3.@config+@bean

4.@import

## spring bean生命周期

1.解析xml配置，或者注解，得到Beandefinition；

2.通过Beandefinition反射建立bean对象

3.对Bean对象的数据进行填充popilateBean().（1-3实例化

4.调用aware接口的一些方法，invokeAwareMethods，对beanname，beanclassload，beanFactory三个属性进行设置

5.调用Beanprocessor初始化前方法

6.调用initmethods法

7.调用Beanprocessor初始化后方法AOP再次实现

8.创建一个bean放入Map当中

9.使用这个bean

10.spring容器关闭时调用disposablebean的destroy关闭这个bean

## bean的创建过程

类--------->无参的构造方式-------------->生成一个对象------->进行依赖注入-------->
初始化前（相当于提前赋值@postConstruct------->

------>初始化（@initaliztingBean-------->初始化后（aop-------->代理对象-------->放入单例池map------->成为BEAN对象

1.创建对象

2.依赖注入（属性填充

3.初始化前填充其他属性

4.初始化

5.初始化后（aop

6.代理对象

7.放入单例池

## 动态代理的两类

jdk动态代理：通过实现InvocationHandler 接口重写invoke方法来实现代理

cglib：通过MethodInterceptor 接口来重写intercept方法实现代理

一般情况下，aop实现了接口就用jdk，没实现必须用cglib，但是都可以用cglib

## spring 事务

四大特性：

原子性，持久性，一致性，隔离性

### 三大基础设施

## osi

1. OSI参考模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层
2. TCP/IP模型(Internet上使用的协议)：网络接口层，网际层，传输层，应用层
3. 网络五层模型：物理层，数据链路层，网络层，传输层，应用层

三次握手，四次挥手

## http特点

1. 客户/服务器模式：
2. 无连接：HTTP协议本身是无连接的，使用TCP连接
3. 无状态：协议对于事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则必须重传；通常在用户主机上存储Cookie文本文件，用于Web服务识别用户。

## http过程

1. 浏览器分析链接指向的页面的URL
2. 浏览器向DNS请求解析URL的IP地址
3. 域名系统DNS解析出IP地址
4. 浏览器与服务器建立TCP连接（默认端口号：80）
5. 浏览器向服务器发出HTTP请求报文
6. 服务器向浏览器发送HTTP响应报文
7. TCP连接终止
8. 浏览器将响应报文进行解释，并将Web页面显示给用户

## get和post区别

### 报文层面：

​ get将请求信息(账号，密码)放在URL中，不安全；
​ post将请求信息放在报文体中，安全

### 数据库层面：

​ get是查询数据的，符合幂等性(多次操作对数据库的结果是相同的)和安全性(对数据库中的操作没有改变数据库中的数据)
​ post是向数据库中提交数据，因此会改变数据库中的数据，post是作用在上一级的URL上的，每一次请求都会添加一份新资源，不符合 幂等性

### 其他层面：

​ get请求可以被缓存，可以保存在浏览器的浏览记录中，能够保存为书签
​ post则不行

## HTTP和HTTPS的区别

1. HTTPS需要到CA申请证书，HTTP不需要
2. HTTPS是密文传输的，HTTP是明文传输的
3. 连接方式不同，HTTPS默认使用443端口，HTTP使用80端口
4. HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全

## 数据库三大范式

第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。

第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。

第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.

第一范式：

​ 每一列属性都是不可再分的属性值，确保每一列的原子性

​ 两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。

第二范式：

​ 要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟
一属性列被称为主键

第三范式：

​ 数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a-->b-->c 属性之间含有这样的关系，是不符合第三 范式的。

## 数据库索引

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC83LzIzLzE2NGM2ZDdhNTY4ODIwYzc?x-oss-process=image/format,png)

### 单列索引

单列索引只针对于某一列数据创建索引，单列索引有以下几种类型：

* **NORMAL：**普通的索引类型，完完全全相当于一本书的目录。
* **UNIQUE：**唯一索引，我们之前已经用过了，一旦建立唯一索引，那么整个列中将不允许出现重复数据。每个表的主键列，都有一个特殊的唯一索引，叫做Primary
  Key，它不仅仅要求不允许出现重复，还要求不能为NULL，它还可以自动递增。每张表可以有多个唯一索引，但是只能有一个Primary索引。
* **SPATIAL：**空间索引，空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON，不是很常用，这里不做介绍。
* **FULLTEXT：**全文索引（MySQL 5.6 之后InnoDB才支持），它是模糊匹配的一种更好的解决方案，它的效率要比使用`like %`
  更高，并且它还支持多种匹配方式，灵活性也更加强大。只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。

我们来看看如何使用全文索引，首先创建一张用于测试全文索引的表：

```sql
CREATE TABLE articles (
  id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
  title VARCHAR(200),
  body TEXT,
  FULLTEXT (body));
```

```sql
INSERT INTO articles VALUES
	(NULL,'MySQL Tutorial', 'DBMS stands for DataBase ...'),
	(NULL,'How To Use MySQL Efficiently', 'After you went through a ...'),
	(NULL,'Optimising MySQL','In this tutorial we will show ...'),
	(NULL,'1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
	(NULL,'MySQL vs. YourSQL', 'In the following database comparison ...'),
	(NULL,'MySQL Security', 'When configured properly, MySQL ...');
```

最后我们使用全文索引进行模糊匹配：

```sql
SELECT * FROM articles WHERE MATCH (body) AGAINST ('database');
```

注意全文索引如何定义字段的，match中就必须是哪些字段，against中定义需要模糊匹配的字符串，我们用作查找的字符串实际上是被分词之后的结果，如果进行模糊匹配的不是一个词语，那么会查找失败，但是它的效率远高于以下这种写法：

```sql
SELECT * FROM articles WHERE body like '%database%';
```

### 组合索引

组合索引实际上就是将多行捆绑在一起，作为一个索引，它同样支持以上几种索引类型，我们可以在Navicat中进行演示。

注意组合索引在进行匹配时，遵循最左原则。

我们可以使用`explain`语句（它可以用于分析select语句的执行计划，也就是MySQL到底是如何在执行某条select语句的）来分析查询语句到底有没有通过索引进行匹配。

```sql
explain select * from student where name = '小王';
```

得到的结果如下：

* select_type：查询类型，上面的就是简单查询（SIMPLE）
* table：查询的表
* type：MySQL决定如何查找对应的记录，效率从高到低：system > const > eq_ref > ref > range > index > all
* possible_keys：执行查询时可能会用到的索引
* key：实际使用的索引
* key_len：Mysql在索引里使用的字节数，字段的最大可能长度
* rows：扫描的行数
* extra：附加说明

### 索引底层原理

在了解完了索引的类型之后，我们接着来看看索引是如何实现的。

既然我们要通过索引来快速查找内容，那么如何设计索引就是我们的重点内容，因为索引是存储在硬盘上的，跟我们之前使用的HashMap之类的不同，它们都是在内存中的，但是硬盘的读取速度远小于内存的速度，每一次IO操作都会耗费大量的时间，我们也不可能把整个磁盘上的索引全部导入内存，因此我们需要考虑尽可能多的减少IO次数，索引的实现可以依靠两种数据结构，一种是我们在JavaSE阶段已经学习过的Hash表，还有一种就是B-Tree。

我们首先来看看哈希表，实际上就是计算Hash值来快速定位：

![点击查看源网页](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnimg.ws.126.net%2F%3Furl%3Dhttp%3A%2F%2Fdingyue.ws.126.net%2F2020%2F1223%2F2dd7c986j00qlrut10012c000rq00eam.jpg%26thumbnail%3D650x2147483647%26quality%3D80%26type%3Djpg&refer=http%3A%2F%2Fnimg.ws.126.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1643975564&t=8c9eabd82da9ac2637b0bdfea57d99bf)

通过对Key进行散列值计算，我们可以直接得到对应数据的存放位置，它的查询效率能够达到O(1)，但是它也存在一定的缺陷：

* Hash索引仅仅能满足“=”，“in”查询条件，不能使用范围查询。
* Hash碰撞问题。
* 不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。

那么，既然要解决这些问题，我们还有一种方案就是使用类似于二叉树那样的数据结构来存储索引，但是这样相比使用Hash索引，会牺牲一定的读取速度。

但是这里并没有使用二叉树，而是使用了BTree，它是专门为磁盘数据读取设计的一种度为n的查找树：

* 树中每个结点最多含有m个孩子（m >= 2）
* 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子。
* 若根结点不是叶子结点，则至少有2个孩子。
* 所有叶子结点都出现在同一层。
* 每个非终端结点中包含有n个键值信息： (P1，K1，P2，K2，P3，......，Kn，Pn+1)。其中：

    1. Ki (i=1...n)为键值，且键值按顺序升序排序K(i-1)< Ki。
    2. Pi为指向子树根的结点，且指针P(i)指向的子树中所有结点的键值均小于Ki，但都大于K(i-1)。
    3. 键值的个数n必须满足： [ceil(m / 2)-1] <= n <= m-1。

![img](https://upload-images.jianshu.io/upload_images/12058546-44a71668594a77d9.png?imageMogr2/auto-orient/strip|imageView2/2/w/654)

比如现在我们要对键值为**10**的记录进行查找，过程如下：

1. 读取根节点数据（目前进行了一次IO操作）
2. 根据根节点数据进行判断得到10<17，因为P1指向的子树中所有值都是小于17的，所以这时我们将P1指向的节点读取（目前进行了两次IO操作）
3. 再次进行判断，得到8<10<12，因为P2指向的子树中所有的值都是小于12大于8的，所以这时读取P2指向的节点（目前进行了三次IO操作）
4. 成功找到。

我们接着来看，虽然BTree能够很好地利用二叉查找树的思想大幅度减少查找次数，但是它的查找效率还是很低，因此它的优化版本B+Tree诞生了，它拥有更稳定的查询效率和更低的IO读取次数：

![img](https://upload-images.jianshu.io/upload_images/12058546-2ae10c0ddc8ac9ea.png?imageMogr2/auto-orient/strip|imageView2/2/w/646)

我们可以发现，它和BTree有一定的区别：

* 有n棵子树的结点中含有n个键值，BTree只有n-1个。
* 所有的键值信息只在叶子节点中包含，非叶子节点仅仅保存子节点的最小（或最大）值，和指向叶子节点的指针，这样相比BTree每一个节点在硬盘中存放了更少的内容（没有键值信息了）
* 所有叶子节点都有一个根据大小顺序指向下一个叶子节点的指针Q，本质上数据就是一个链表。

这样，读取IO的时间相比BTree就减少了很多，并且查询任何键值信息都需要完整地走到叶子节点，保证了查询的IO读取次数一致。因此MySQL默认选择B+Tree作为索引的存储数据结构。

这是MyISAM存储引擎下的B+Tree实现：

![img](https://upload-images.jianshu.io/upload_images/12058546-316168444236022b.png?imageMogr2/auto-orient/strip|imageView2/2/w/664)

这是InnoDB存储引擎下的B+Tree实现：

![img](https://upload-images.jianshu.io/upload_images/12058546-0da96cb9de1ff1c3.png?imageMogr2/auto-orient/strip|imageView2/2/w/543)

![img](https://upload-images.jianshu.io/upload_images/12058546-8cb0dbfd433253b4.png?imageMogr2/auto-orient/strip|imageView2/2/w/543)

InnoDB与MyISAM实现的不同之处：

* 数据本身就是索引的一部分（所以这里建议主键使用自增）
* 非主键索引的数据实际上存储的是对应记录的主键值（因此InnoDB必须有主键，若没有也会自动查找替代）

## b树和b+树

![b65b9b2c5013ccb8808c092bbdca5ed4.png](https://img-blog.csdnimg.cn/img_convert/b65b9b2c5013ccb8808c092bbdca5ed4.png)

**B 树**可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。

· 根节点至少有两个子节点

· 每个节点有M-1个key，并且以升序排列

· 位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间

· 其它节点至少有M/2个子节点

下图是一个M=4 阶的B树:

![43456b9f68798b9aebc29ee0e50b4aad.png](https://img-blog.csdnimg.cn/img_convert/43456b9f68798b9aebc29ee0e50b4aad.png)

**B+**树是对B树的一种变形树，它与B树的差异在于：

· 有k个子结点的结点必然有k个关键码；

· 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。

· 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录

B+树的有点就是非叶子节点仅仅作为索引，并没有存放内容。而叶子节点组成一个链表，读取更快速

## innodb和MyISAM

myisam：非聚集索引

索引的叶子节点仍然不存储数据，仍然是个索引，指向数据

innodb：聚集索引

索引的叶子节点直接存储数据。

1、MyISAM是非事务安全的，而InnoDB是事务安全的

2、MyISAM锁的粒度是表级的，而InnoDB支持行级锁

3、MyISAM支持全文类型索引，而InnoDB不支持全文索引

4、MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM

5、MyISAM表保存成文件形式，跨平台使用更加方便

6、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量select操作可选择

7、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，可选择。
